<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/subsystems/talonfx_drivesubsystem.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/subsystems/talonfx_drivesubsystem.py" />
              <option name="updatedContent" value="&#10;                )&#10;                self.currentTranslationMag = self.magLimiter.calculate(0.0)&#10;&#10;            self.prevTime = currentTime&#10;&#10;            xSpeedCommanded = self.currentTranslationMag * math.cos(&#10;                self.currentTranslationDir&#10;            )&#10;            ySpeedCommanded = self.currentTranslationMag * math.sin(&#10;                self.currentTranslationDir&#10;            )&#10;            self.currentRotation = self.rotLimiter.calculate(rot)&#10;&#10;        else:&#10;            self.currentRotation = rot&#10;&#10;        # Convert the commanded speeds into the correct units for the drivetrain&#10;        xSpeedDelivered = xSpeedCommanded * TalonFXDrivingConstants.kMaxMetersPerSecond&#10;        ySpeedDelivered = ySpeedCommanded * TalonFXDrivingConstants.kMaxMetersPerSecond&#10;        rotDelivered = self.currentRotation * TalonFXDrivingConstants.kMaxAngularSpeed&#10;&#10;        swerveModuleStates = TalonFXDrivingConstants.kDriveKinematics.toSwerveModuleStates(&#10;            ChassisSpeeds.fromFieldRelativeSpeeds(&#10;                xSpeedDelivered,&#10;                ySpeedDelivered,&#10;                rotDelivered,&#10;                self.getGyroHeading(),&#10;            )&#10;            if fieldRelative&#10;            else ChassisSpeeds(xSpeedDelivered, ySpeedDelivered, rotDelivered)&#10;        )&#10;        fl, fr, rl, rr = SwerveDrive4Kinematics.desaturateWheelSpeeds(&#10;            swerveModuleStates, TalonFXDrivingConstants.kMaxMetersPerSecond&#10;        )&#10;        self.frontLeft.setDesiredState(fl)&#10;        self.frontRight.setDesiredState(fr)&#10;        self.rearLeft.setDesiredState(rl)&#10;        self.rearRight.setDesiredState(rr)&#10;&#10;    def getRobotRelativeSpeeds(self) -&gt; ChassisSpeeds:&#10;        &quot;&quot;&quot;Returns the robot-relative chassis speeds&quot;&quot;&quot;&#10;        return TalonFXDrivingConstants.kDriveKinematics.toChassisSpeeds(&#10;            self.frontLeft.getState(),&#10;            self.frontRight.getState(),&#10;            self.rearLeft.getState(),&#10;            self.rearRight.getState()&#10;        )&#10;&#10;    def driveRobotRelative(self, chassisSpeeds: ChassisSpeeds) -&gt; None:&#10;        &quot;&quot;&quot;Drive the robot with robot-relative chassis speeds&quot;&quot;&quot;&#10;        swerveModuleStates = TalonFXDrivingConstants.kDriveKinematics.toSwerveModuleStates(chassisSpeeds)&#10;        self.setModuleStates(swerveModuleStates)&#10;&#10;    def setX(self) -&gt; None:&#10;        &quot;&quot;&quot;Sets the wheels into an X formation to prevent movement.&quot;&quot;&quot;&#10;        self.frontLeft.setDesiredState(SwerveModuleState(0, Rotation2d.fromDegrees(45)))&#10;        self.frontRight.setDesiredState(&#10;            SwerveModuleState(0, Rotation2d.fromDegrees(-45))&#10;        )&#10;        self.rearLeft.setDesiredState(SwerveModuleState(0, Rotation2d.fromDegrees(-45)))&#10;        self.rearRight.setDesiredState(SwerveModuleState(0, Rotation2d.fromDegrees(45)))&#10;&#10;    def setModuleStates(&#10;        self,&#10;        desiredStates: typing.Tuple[&#10;            SwerveModuleState, SwerveModuleState, SwerveModuleState, SwerveModuleState&#10;        ],&#10;    ) -&gt; None:&#10;        &quot;&quot;&quot;Sets the swerve ModuleStates.&#10;&#10;        :param desiredStates: The desired SwerveModule states.&#10;        &quot;&quot;&quot;&#10;        fl, fr, rl, rr = SwerveDrive4Kinematics.desaturateWheelSpeeds(&#10;            desiredStates, TalonFXDrivingConstants.kMaxMetersPerSecond&#10;        )&#10;        self.frontLeft.setDesiredState(fl)&#10;        self.frontRight.setDesiredState(fr)&#10;        self.rearLeft.setDesiredState(rl)&#10;        self.rearRight.setDesiredState(rr)&#10;&#10;    def resetEncoders(self) -&gt; None:&#10;        &quot;&quot;&quot;Resets the drive encoders to currently read a position of 0.&quot;&quot;&quot;&#10;        self.frontLeft.resetEncoders()&#10;        self.rearLeft.resetEncoders()&#10;        self.frontRight.resetEncoders()&#10;        self.rearRight.resetEncoders()&#10;&#10;    def getGyroHeading(self) -&gt; Rotation2d:&#10;        &quot;&quot;&quot;Returns the heading of the robot, tries to be smart when gyro is disconnected&#10;&#10;        :returns: the robot's heading as Rotation2d&#10;        &quot;&quot;&quot;&#10;        now = wpilib.Timer.getFPGATimestamp()&#10;        past = self._lastGyroAngleTime&#10;        state = &quot;ok&quot;&#10;&#10;        if not self.gyro.isConnected():&#10;            state = &quot;disconnected&quot;&#10;        else:&#10;            if self.gyro.isCalibrating():&#10;                state = &quot;calibrating&quot;&#10;            self._lastGyroAngle = self.gyro.getAngle()&#10;            self._lastGyroAngleTime = now&#10;&#10;        if state != self._lastGyroState:&#10;            SmartDashboard.putString(&quot;gyro&quot;, f&quot;{state} after {int(now - past)}s&quot;)&#10;            self._lastGyroState = state&#10;&#10;        return Rotation2d.fromDegrees(self._lastGyroAngle * TalonFXDrivingConstants.kGyroReversed)&#10;&#10;    def getTurnRate(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the turn rate of the robot (in degrees per second)&#10;&#10;        :returns: The turn rate of the robot, in degrees per second&#10;        &quot;&quot;&quot;&#10;        return self.gyro.getRate() * TalonFXDrivingConstants.kGyroReversed&#10;&#10;    def getTurnRateDegreesPerSec(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the turn rate of the robot (in degrees per second)&#10;&#10;        :returns: The turn rate of the robot, in degrees per second&#10;        &quot;&quot;&quot;&#10;        return self.getTurnRate() * 180 / math.pi" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/subsystems/talonfx_swervemodule.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/subsystems/talonfx_swervemodule.py" />
              <option name="updatedContent" value="from phoenix6.hardware import TalonFX, CANcoder&#10;from phoenix6.configs import TalonFXConfigurator, TalonFXConfiguration, CANcoderConfiguration&#10;from phoenix6.signals import NeutralModeValue, InvertedValue&#10;from phoenix6.controls import VelocityVoltage, PositionVoltage&#10;&#10;from wpimath.geometry import Rotation2d&#10;from wpimath.kinematics import SwerveModuleState, SwerveModulePosition&#10;&#10;from constants import TalonFXModuleConstants&#10;&#10;&#10;class TalonFXSwerveModule:&#10;    &quot;&quot;&quot;&#10;    TalonFX-based swerve module using Kraken X60 motors&#10;    &quot;&quot;&quot;&#10;    def __init__(&#10;            self,&#10;            drivingCANId: int,&#10;            turningCANId: int,&#10;            chassisAngularOffset: float,&#10;            turnMotorInverted: bool,&#10;    ) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Initializes a TalonFX SwerveModule with Kraken X60 motors.&#10;        :param drivingCANId: CAN ID for the driving motor&#10;        :param turningCANId: CAN ID for the turning motor  &#10;        :param chassisAngularOffset: Angular offset for the chassis&#10;        :param turnMotorInverted: Whether the turning motor is inverted&#10;        &quot;&quot;&quot;&#10;        &#10;        self.chassisAngularOffset = chassisAngularOffset&#10;        self.desiredState = SwerveModuleState(0.0, Rotation2d(0.0))&#10;        &#10;        # Initialize TalonFX motors&#10;        self.drivingMotor = TalonFX(drivingCANId)&#10;        self.turningMotor = TalonFX(turningCANId)&#10;        &#10;        # Configure driving motor&#10;        self._configureDrivingMotor()&#10;        &#10;        # Configure turning motor&#10;        self._configureTurningMotor(turnMotorInverted)&#10;        &#10;        # Reset encoders&#10;        self.resetEncoders()&#10;&#10;    def _configureDrivingMotor(self):&#10;        &quot;&quot;&quot;Configure the driving TalonFX motor&quot;&quot;&quot;&#10;        config = TalonFXConfiguration()&#10;        &#10;        # Motor output settings&#10;        config.motor_output.neutral_mode = TalonFXModuleConstants.kDrivingMotorIdleMode&#10;        config.motor_output.inverted = InvertedValue.COUNTER_CLOCKWISE_POSITIVE&#10;        &#10;        # Current limits&#10;        config.current_limits.supply_current_limit_enable = True&#10;        config.current_limits.supply_current_limit = TalonFXModuleConstants.kDrivingMotorCurrentLimit&#10;        &#10;        # PID configuration for velocity control&#10;        config.slot0.k_p = TalonFXModuleConstants.kDrivingP&#10;        config.slot0.k_i = TalonFXModuleConstants.kDrivingI&#10;        config.slot0.k_d = TalonFXModuleConstants.kDrivingD&#10;        config.slot0.k_v = TalonFXModuleConstants.kDrivingFF&#10;        &#10;        # Apply configuration&#10;        self.drivingMotor.configurator.apply(config)&#10;        &#10;        # Create velocity control request&#10;        self.velocityRequest = VelocityVoltage(0)&#10;&#10;    def _configureTurningMotor(self, turnMotorInverted: bool):&#10;        &quot;&quot;&quot;Configure the turning TalonFX motor&quot;&quot;&quot;&#10;        config = TalonFXConfiguration()&#10;        &#10;        # Motor output settings&#10;        config.motor_output.neutral_mode = TalonFXModuleConstants.kTurningMotorIdleMode&#10;        config.motor_output.inverted = InvertedValue.CLOCKWISE_POSITIVE if turnMotorInverted else InvertedValue.COUNTER_CLOCKWISE_POSITIVE&#10;        &#10;        # Current limits&#10;        config.current_limits.supply_current_limit_enable = True&#10;        config.current_limits.supply_current_limit = TalonFXModuleConstants.kTurningMotorCurrentLimit&#10;        &#10;        # PID configuration for position control&#10;        config.slot0.k_p = TalonFXModuleConstants.kTurningP&#10;        config.slot0.k_i = TalonFXModuleConstants.kTurningI&#10;        config.slot0.k_d = TalonFXModuleConstants.kTurningD&#10;        config.slot0.k_v = TalonFXModuleConstants.kTurningFF&#10;        &#10;        # Apply configuration&#10;        self.turningMotor.configurator.apply(config)&#10;        &#10;        # Create position control request&#10;        self.positionRequest = PositionVoltage(0)&#10;&#10;    def getState(self) -&gt; SwerveModuleState:&#10;        &quot;&quot;&quot;Returns the current state of the module.&#10;&#10;        :returns: The current state of the module.&#10;        &quot;&quot;&quot;&#10;        return SwerveModuleState(&#10;            self.getDrivingVelocity(),&#10;            Rotation2d(self.getTurningPosition())&#10;        )&#10;&#10;    def getPosition(self) -&gt; SwerveModulePosition:&#10;        &quot;&quot;&quot;Returns the current position of the module.&#10;&#10;        :returns: The current position of the module.&#10;        &quot;&quot;&quot;&#10;        return SwerveModulePosition(&#10;            self.getDrivingPosition(),&#10;            Rotation2d(self.getTurningPosition())&#10;        )&#10;&#10;    def setDesiredState(self, desiredState: SwerveModuleState) -&gt; None:&#10;        &quot;&quot;&quot;Sets the desired state for the module.&#10;&#10;        :param desiredState: Desired state with speed and angle.&#10;        &quot;&quot;&quot;&#10;        # Optimize the reference state to avoid spinning further than 90 degrees&#10;        optimizedState = SwerveModuleState.optimize(&#10;            desiredState, Rotation2d(self.getTurningPosition())&#10;        )&#10;&#10;        # Scale speed by cosine of angle error to decrease energy usage&#10;        optimizedState.speed *= (optimizedState.angle - Rotation2d(self.getTurningPosition())).cos()&#10;&#10;        self.desiredState = optimizedState&#10;&#10;        # Convert to motor units and set references&#10;        drivingVelocityRPS = optimizedState.speed / TalonFXModuleConstants.kDrivingEncoderVelocityFactor&#10;        turningPositionRotations = optimizedState.angle.radians() / TalonFXModuleConstants.kTurningEncoderPositionFactor&#10;&#10;        # Set motor references&#10;        self.drivingMotor.set_control(self.velocityRequest.with_velocity(drivingVelocityRPS))&#10;        self.turningMotor.set_control(self.positionRequest.with_position(turningPositionRotations))&#10;&#10;    def resetEncoders(self) -&gt; None:&#10;        &quot;&quot;&quot;Resets the drive encoders to currently read a position of 0.&quot;&quot;&quot;&#10;        self.drivingMotor.set_position(0)&#10;&#10;    def getDrivingPosition(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the driving position in meters.&quot;&quot;&quot;&#10;        return self.drivingMotor.get_position().value * TalonFXModuleConstants.kDrivingEncoderPositionFactor&#10;&#10;    def getDrivingVelocity(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the driving velocity in m/s.&quot;&quot;&quot;&#10;        return self.drivingMotor.get_velocity().value * TalonFXModuleConstants.kDrivingEncoderVelocityFactor&#10;&#10;    def getTurningPosition(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the turning position in radians.&quot;&quot;&quot;&#10;        return self.turningMotor.get_position().value * TalonFXModuleConstants.kTurningEncoderPositionFactor&#10;&#10;    def getTurningVelocity(self) -&gt; float:&#10;        &quot;&quot;&quot;Returns the turning velocity in rad/s.&quot;&quot;&quot;&#10;        return self.turningMotor.get_velocity().value * TalonFXModuleConstants.kTurningEncoderVelocityFactor" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>